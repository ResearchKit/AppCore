// 
//  APCScheduler.m 
//  APCAppCore 
// 
//  Copyright (c) 2015, Apple Inc. All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without modification,
//  are permitted provided that the following conditions are met:
//
//  1.  Redistributions of source code must retain the above copyright notice, this
//  list of conditions and the following disclaimer.
//
//  2.  Redistributions in binary form must reproduce the above copyright notice,
//  this list of conditions and the following disclaimer in the documentation and/or
//  other materials provided with the distribution.
//
//  3.  Neither the name of the copyright holder(s) nor the names of any contributors
//  may be used to endorse or promote products derived from this software without
//  specific prior written permission. No license is granted to the trademarks of
//  the copyright holders even if such marks are included in this software.
//
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
//  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
//  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
//  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
//  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
 

#import "APCScheduler.h"

#import "APCAppDelegate.h"
#import "APCDataSubstrate.h"
#import "APCDateRange.h"
#import "APCGenericSurveyTaskViewController.h"
#import "APCTask+AddOn.h"
#import "APCTaskGroup.h"
#import "APCTaskGroupCacheEntry.h"
#import "APCUser.h"
#import "APCUtilities.h"
#import "NSArray+APCHelper.h"
#import "NSDate+Helper.h"
#import "NSDictionary+APCAdditions.h"
#import "NSOperationQueue+Helper.h"
#import "APCTaskImporter.h"
#import "NSManagedObject+APCHelper.h"
#import "NSError+APCAdditions.h"
#import "APCLog.h"


/**
 Location of the static tasks-and-schedules file on disk,
 and dictionary keys in that file.
 */
static NSString * const kAPCStaticJSONTasksAndSchedulesFileName      = @"APHTasksAndSchedules.json";
static NSString * const kAPCStaticJSONTasksAndSchedulesSchedulesKey  = @"schedules";
static NSString * const kAPCStaticJSONTasksAndSchedulesTasksKey      = @"tasks";            // Deprecated.


/**
 Error codes and messages generated by this class.
 */
typedef enum : NSUInteger {
    APCErrorCouldntFetchActiveSchedulesForDateCode,
    APCErrorCouldntFetchVisibleSchedulesForDateCode,
    APCErrorDeletingTaskCode,
    APCErrorJSONTasksAndScheduleIsNotAnArrayCode,
    APCErrorJSONTasksAndSchedulesIsEmptyCode,
    APCErrorJSONTasksAndSchedulesNilValueForKeyCode,
    APCErrorLoadingJsonFromDiskCode,
    APCErrorSavingToPeristentStoreCode,
    APCErrorServerDisabledCode,
}   APCError;

static NSString * const APCErrorDomainLoadingTasksAndSchedules                      = @"kAPCErrorDomainLoadingTasksAndSchedules";

static NSString * const APCErrorCouldntFetchActiveSchedulesForDateReason            = @"Couldn't fetch active schedules for given date";
static NSString * const APCErrorCouldntFetchActiveSchedulesForDateSuggestion        = @"There was an error executing a fetch request for active APCSchedules with this date.";
static NSString * const APCErrorCouldntFetchVisibleSchedulesForDateReason           = @"Couldn't fetch visible schedules for given date";
static NSString * const APCErrorCouldntFetchVisibleSchedulesForDateSuggestion       = @"There was an error executing a fetch request for visible APCSchedules with this date.";
static NSString * const APCErrorDeletingTaskReason                                  = @"Error attempting to delete task.";
static NSString * const APCErrorDeletingTaskSuggestion                              = @"Error attempting to delete task. This may give the user unexpected results.";
static NSString * const APCErrorJSONTasksAndScheduleIsNotAnArrayReason              = @"The JSON tasks and schedules key is returning an incorrect type";
static NSString * const APCErrorJSONTasksAndScheduleIsNotAnArraySuggestion          = @"The expected type from the JSON tasks and schedules key is an array.";
static NSString * const APCErrorJSONTasksAndSchedulesIsEmptyReason                  = @"The JSON tasks and schedules key is returning an empty array";
static NSString * const APCErrorJSONTasksAndSchedulesIsEmptySuggestion              = @"The JSON tasks and schedules may be incomplete because the array count is zero.";
static NSString * const APCErrorJSONTasksAndSchedulesNilValueForKeyReason           = @"The JSON tasks and schedules key returns nil";
static NSString * const APCErrorJSONTasksAndSchedulesNilValueForKeySuggestion       = @"The JSON tasks and schedules key returns nil. The key may be incorrect or the file is empty.";
static NSString * const APCErrorLoadingJsonFromDiskReason                           = @"Can't Open JSON File";
static NSString * const APCErrorLoadingJsonFromDiskSuggestion                       = @"We were unable to open the specified file as JSON.";
static NSString * const APCErrorSavingToPeristentStoreReason                        = @"Error attempting to save new APCScheduledTask";
static NSString * const APCErrorSavingToPeristentStoreSuggestion                    = @"Error attempting to save new APCScheduledTask. This may give the user unexpected results.";
static NSString * const APCErrorServerDisabledReason                                = @"Server disabled";
static NSString * const APCErrorServerDisabledSuggestion                            = @"The server is disabled.";
static NSString * const APCErrorTooManyTasksWithSameIDReason                        = @"More than one task with this ID";
static NSString * const APCErrorTooManyTasksWithSameIDSuggestion                    = @"We found more than one task with this ID. This will give the user unexpected results.";


/**
 The name of the queue where this class does most of its work.
 */
static NSString * const kQueueName = @"APCScheduler CoreData query queue";


@interface APCScheduler()
@property (nonatomic, weak)   APCDataSubstrate        *dataSubstrate;
@property (nonatomic, strong) NSManagedObjectContext  *scheduleMOC;
@property (nonatomic, strong) NSOperationQueue        *queryQueue;
@property (nonatomic, assign) BOOL                    isUpdating;
@property (nonatomic, strong) NSDateFormatter         *dateFormatter;
@property (nonatomic, strong) NSMutableArray          *taskGroupCache;
@property (nonatomic, strong) NSObject                *taskGroupCacheMutex;
@property (readonly)          APCAppDelegate          *appDelegate;
@property (readonly)          NSDate                  *systemDate;
@end

@implementation APCScheduler



// =========================================================
#pragma mark - I. SETUP -
// =========================================================

+ (APCScheduler *) defaultScheduler
{
    APCAppDelegate *app = [APCAppDelegate sharedAppDelegate];
    APCScheduler *scheduler = app.scheduler;
    return scheduler;
}

- (instancetype) initWithDataSubstrate: (APCDataSubstrate *) dataSubstrate
{
    self = [super init];

    if (self)
    {
        _dataSubstrate              = dataSubstrate;
        _scheduleMOC                = _dataSubstrate.persistentContext; // TODO: Dig deeper into if this is necessary, can result in concurrency errors if multiple threads access
        _queryQueue                 = [NSOperationQueue sequentialOperationQueueWithName: kQueueName];
        _isUpdating                 = NO;
        _dateFormatter              = [NSDateFormatter new];
        _dateFormatter.dateStyle    = NSDateFormatterMediumStyle;
        _dateFormatter.timeStyle    = NSDateFormatterMediumStyle;
        _fakeSystemDate             = nil;
        _taskGroupCache             = [NSMutableArray new];
        _taskGroupCacheMutex        = [NSObject new];
    }

    return self;
}



// =========================================================
#pragma mark - II. QUERYING -
// =========================================================



// ---------------------------------------------------------
#pragma mark - Fetching tasks for all days in a range
// ---------------------------------------------------------

- (void) fetchTaskGroupsFromDate: (NSDate *) startDate
                          toDate: (NSDate *) endDate
                      usingQueue: (NSOperationQueue *) queue
                 toReportResults: (APCSchedulerCallbackForTaskGroupQueries) callbackBlock
{
    [self fetchTaskGroupsFromDate: startDate
                           toDate: endDate
           forTasksMatchingFilter: nil
                       usingQueue: queue
                  toReportResults: callbackBlock];
}

- (void) fetchTaskGroupsFromDate: (NSDate *) startDate
                          toDate: (NSDate *) endDate
          forTasksMatchingFilter: (NSPredicate *) taskFilter
                      usingQueue: (NSOperationQueue *) queue
                 toReportResults: (APCSchedulerCallbackForTaskGroupQueries) callbackBlock
{
    [self.queryQueue addOperationWithBlock: ^{

        NSMutableDictionary *results = [NSMutableDictionary new];
        NSDate *dayAfterEndDate = endDate.dayAfter.startOfDay;
        NSDate *date = startDate.startOfDay;

        for (date = startDate.startOfDay; [date isEarlierThanDate: dayAfterEndDate]; date = [date dateByAddingDays: 1])
        {
            NSArray *taskGroups = [self taskGroupsForDayOfDate: date
                                        forTasksMatchingFilter: taskFilter];
            
            if (taskGroups.count > 0) {
                results [date] = taskGroups;
            }
        }

        if (queue != nil && callbackBlock != nil)
        {
            [queue addOperationWithBlock:^{
                callbackBlock (results, nil);
            }];
        }
    }];
}

- (NSArray *) taskGroupsForDayOfDate: (NSDate *) date
              forTasksMatchingFilter: (NSPredicate *) taskFilter
{
    NSArray *taskGroupsToReport = nil;

    NSArray *cachedTaskGroups = [self cachedTaskGroupsForDayOfDate: date
                                            forTasksMatchingFilter: taskFilter];

    if (cachedTaskGroups)
    {
        taskGroupsToReport = cachedTaskGroups;
    }

    else
    {
        taskGroupsToReport = [self uncachedTaskGroupsForDayOfDate:date
                                           forTasksMatchingFilter: taskFilter];


        
        /*
         Lastly:  cache these results, because of the performance problem
         mentioned at the top of this method.
         
         Note that another thread might have come through here and
         cache this same list of stuff while we were working.  That's
         fine.  The cachcing mechanism is thread-safe, and stores the
         first set of results matching this date range and filter, so
         even if a bunch of threads try to do this simultaneously,
         only one will win, and every subsequent request will use
         that cached value.
         */
        [self cacheTaskGroups: taskGroupsToReport
                      forDate: date
                    andFilter: taskFilter];
    }
    
    return taskGroupsToReport;
}


- (NSArray *) uncachedTaskGroupsForDayOfDate: (NSDate *) theSpecifiedDate
                      forTasksMatchingFilter: (NSPredicate *) taskFilter
{
    NSError *errorFetchingTasks         = nil;
    NSManagedObjectContext *context         = self.scheduleMOC;
    NSArray *todaysTasks = [self tasksScheduledForDayOfDate: theSpecifiedDate
                                               usingContext: context
                                                usingFilter:taskFilter
                                             returningError: &errorFetchingTasks];
    
    
    NSMutableDictionary *taskGroupsDictionary = [NSMutableDictionary new];
    for (APCTask *task in todaysTasks) {
        NSMutableArray *groupOfTasks = [taskGroupsDictionary objectForKey:task.taskID];
        if (!groupOfTasks) {
            groupOfTasks = [NSMutableArray new];
            [taskGroupsDictionary setObject:groupOfTasks forKey:task.taskID];
        }
        [groupOfTasks addObject:task];
    }
    NSMutableArray *taskGroups = [NSMutableArray new];
    [taskGroupsDictionary enumerateKeysAndObjectsUsingBlock:^(__unused id key, id object, __unused BOOL *stop) {
        NSArray *tasks = (NSArray*)object;
        APCTaskGroup *taskGroup = [[APCTaskGroup alloc] initWithTasks:tasks
                                                     forScheduledDate:theSpecifiedDate];
        [taskGroups addObject:taskGroup];
    }];
    
    NSArray *sortedGroups = [taskGroups sortedArrayUsingSelector: @selector(compareWithTaskGroup:)];
    
    return sortedGroups;
}


- (NSArray *) tasksScheduledForDayOfDate: (NSDate *) dateWhenThingsShouldBeVisible
                            usingContext: (NSManagedObjectContext *) context
                             usingFilter:(NSPredicate *) taskFilter
                          returningError: (NSError * __autoreleasing *) errorToReturn
{
    NSDate *midnightThisMorning = dateWhenThingsShouldBeVisible.startOfDay;
    NSDate *midnightThisEvening = dateWhenThingsShouldBeVisible.endOfDay;
    
    // Check that scheduledFor date is today or earlier
    // Check that expires date does not exist or is later than the start of today
    // Check that finishedDate does not exist or is later than the start of today
    NSPredicate *filterForThisDay = [NSPredicate predicateWithFormat:
                                     @"(%K <= %@) && (%K == nil OR %K.length == 0 OR %K >= %@) && (%K == nil OR %K.length == 0 OR %K >= %@)",
                                     NSStringFromSelector (@selector (taskScheduledFor)),           // -[APCTask taskScheduledFor]
                                     midnightThisEvening,
                                     NSStringFromSelector (@selector (taskExpires)),           // -[APCTask taskExpires]
                                     NSStringFromSelector (@selector (taskExpires)),           // -[APCTask taskExpires]
                                     NSStringFromSelector (@selector (taskExpires)),           // -[APCTask taskExpires]
                                     midnightThisMorning,
                                     NSStringFromSelector (@selector (taskFinished)),           // -[APCTask taskFinished]
                                     NSStringFromSelector (@selector (taskFinished)),           // -[APCTask taskFinished]
                                     NSStringFromSelector (@selector (taskFinished)),           // -[APCTask taskFinished]
                                     midnightThisMorning
                                     ];
    
    NSPredicate *compoundPredicate = [NSCompoundPredicate andPredicateWithSubpredicates:@[taskFilter, filterForThisDay]];
    
    NSFetchRequest *taskQuery = [APCTask requestWithPredicate: compoundPredicate];
    NSError *errorFetchingTasks = nil;
    NSArray *tasks = [context executeFetchRequest: taskQuery
                                            error: &errorFetchingTasks];
    
    if (errorFetchingTasks)
    {
        *errorToReturn = [NSError errorWithCode: APCErrorCouldntFetchVisibleSchedulesForDateCode
                                         domain: APCErrorDomainLoadingTasksAndSchedules
                                  failureReason: APCErrorCouldntFetchVisibleSchedulesForDateReason
                             recoverySuggestion: APCErrorCouldntFetchVisibleSchedulesForDateSuggestion
                                    nestedError: errorFetchingTasks];
    }
    
    return tasks;
}




// =========================================================
#pragma mark - III. IMPORTING -
// =========================================================



// ---------------------------------------------------------
#pragma mark - Downloading tasks from the server
// ---------------------------------------------------------

- (void) fetchTasksFromServerAndThenUseThisQueue: (NSOperationQueue *) queue
                                toDoThisWhenDone: (APCSchedulerCallbackForFetchAndLoadOperations) callbackBlock
{
    /*
     Get off whatever thread we were called on.  For this outer "if"
     statement, we'll only be here for an instant, but for consistency
     in all our data-handling, we'll do everything on the same thread.
     */
    [self.queryQueue addOperationWithBlock:^{
        
        if (self.isServerDisabled)
        {
            APCLogDebug (@"SERVER COMMUNICATION DISABLED:  Server communication has been (purposely?) disabled.  Not fetching schedules from the server.");
            
            NSError *errorFetchingSchedules = [NSError errorWithCode: APCErrorServerDisabledCode
                                                              domain: APCErrorDomainLoadingTasksAndSchedules
                                                       failureReason: APCErrorServerDisabledReason
                                                  recoverySuggestion: APCErrorServerDisabledSuggestion];
            
            [self handleErrorFetchingTasksAndSchedulesFromServer: errorFetchingSchedules
                                             andThenUseThisQueue: queue
                                                        toDoThis: callbackBlock];
        }
        else
        {
            /*
             Bounce over to the Bridge SDK's thread, call the server, and then come
             back to our thread a while later.
             */
            [SBBComponent (SBBTaskManager) getTasksForDaysAhead:3
                                          withCompletion:^(SBBResourceList *tasksList,
                                                           NSError *errorFetchingTasks)
             {
                 /*
                  Immediately get off the BridgeSDK queue and back onto ours,
                  so we know and can control what's happening and what
                  resources are being used.
                  */
                 [self.queryQueue addOperationWithBlock: ^{
                     
                     [self handleSuccessfullyFetchedTasksFromServer: tasksList
                       givenThisPossibleErrorFromTheDownloadProcess: errorFetchingTasks
                                                andThenUseThisQueue: queue
                                                           toDoThis: callbackBlock];
                 }];
             }];
            
        }
    }];
}


/**
 By the time we get here, we're safely on our private thread
 (a private serial queue).
 */
- (void) handleErrorFetchingTasksAndSchedulesFromServer: (NSError *) errorFetchingSchedules
                                    andThenUseThisQueue: (NSOperationQueue *) queue
                                               toDoThis: (APCSchedulerCallbackForFetchAndLoadOperations) callbackBlock
{
    APCLogError2 (errorFetchingSchedules);

    [self performFetchAndLoadCallback: callbackBlock
                              onQueue: queue
                         sendingError: errorFetchingSchedules];
}

/**
 By the time we get here, we're safely on our private thread
 (a private serial queue).
 */
- (void) handleSuccessfullyFetchedTasksFromServer: (SBBResourceList *) tasks
     givenThisPossibleErrorFromTheDownloadProcess: (NSError *) errorFetchingtasks
                              andThenUseThisQueue: (NSOperationQueue *) queue
                                         toDoThis: (APCSchedulerCallbackForFetchAndLoadOperations) callbackBlock
{
    APCTaskImporter *importEngine = [APCTaskImporter new];
    
    if (errorFetchingtasks)
    {
        [self handleErrorFetchingTasksAndSchedulesFromServer: errorFetchingtasks
                                         andThenUseThisQueue: queue
                                                    toDoThis: callbackBlock];
    }
    else
    {
        NSMutableArray *jsonCopyOfSageTasks = nil;
        
        if (!errorFetchingtasks)
        {
            jsonCopyOfSageTasks = [NSMutableArray new];
            NSArray *sageTasks = tasks.items;
            
            for (SBBTask *sageTask in sageTasks)
            {
                NSDictionary *sageTaskData = [importEngine extractJsonDataFromIncomingSageTask:sageTask];
                
                if (sageTaskData) {
                    [jsonCopyOfSageTasks addObject: sageTaskData];
                }
            }
        }
        
        /*
         Loop through the incoming items and save/udpate everything.
         */
        [self processTasks: jsonCopyOfSageTasks
                fromSource: APCTaskSourceServer
       andThenUseThisQueue: queue
          toDoThisWhenDone: callbackBlock];
    }
}



// ---------------------------------------------------------
#pragma mark - The core task import process
// ---------------------------------------------------------



- (void) processTasks: (NSArray *) arrayOfTasks
           fromSource: (APCTaskSource) taskSource
  andThenUseThisQueue: (NSOperationQueue *) queue
     toDoThisWhenDone: (APCSchedulerCallbackForFetchAndLoadOperations) callbackBlock
{
    NSManagedObjectContext *context = self.scheduleMOC;
    APCTaskImporter *importEngine = [APCTaskImporter new];
    NSError *error = nil;
    
    [importEngine processTasks: arrayOfTasks
                    fromSource: taskSource
                  usingContext: context
                returningError: &error];
    
    [self clearTaskGroupCache];
    
    if (error)
    {
        APCLogError2 (error);
    }
    
    [self performFetchAndLoadCallback: callbackBlock
                              onQueue: queue
                         sendingError: error];
}



// =========================================================
#pragma mark - IV. MANAGING STARTING AND FINISHING OF TASKS -
// =========================================================


- (APCTask*) startTask:(APCTask*) startedTask {
    startedTask.taskStarted = [NSDate date];
    NSError * saveError;
    [startedTask saveToPersistentStore:&saveError];
    APCLogError2 (saveError);
    
    /*
     Clear the taskGroup cache, so UIs (and anything else
     depending on the cached taskGroups) draw correctly.
     This operation is thread-safe.
     */
    [self clearTaskGroupCache];
    
    return startedTask;
}

- (APCTask*) finishTask:(APCTask*) completedTask {
    completedTask.taskFinished = [NSDate date];
    NSError * saveError;
    [completedTask saveToPersistentStore:&saveError];
    APCLogError2 (saveError);
    
    /*
     Clear the taskGroup cache, so UIs (and anything else
     depending on the cached taskGroups) draw correctly.
     This operation is thread-safe.
     */
    [self clearTaskGroupCache];
    
    return completedTask;
}

- (APCTask*) abortTask:(APCTask*) abortedTask {
    abortedTask.taskStarted = nil;
    NSError * saveError;
    [abortedTask saveToPersistentStore:&saveError];
    APCLogError2 (saveError);
    
    /*
     Clear the taskGroup cache, so UIs (and anything else
     depending on the cached taskGroups) draw correctly.
     This operation is thread-safe.
     */
    [self clearTaskGroupCache];
    
    return abortedTask;
}


// =========================================================
#pragma mark - V. UTILITIES -
// =========================================================


// ---------------------------------------------------------
#pragma mark - Replying to the method who called us
// ---------------------------------------------------------

/**
 A local utility function, which checks for nil in both the
 callbackBlock and the queue before queueing that block on
 that queue, solely so we don't have to repeat those "if"
 clauses everywhere we do this.
 */
- (void) performFetchAndLoadCallback: (APCSchedulerCallbackForFetchAndLoadOperations) callbackBlock
                             onQueue: (NSOperationQueue *) queue
                        sendingError: (NSError *) error
{
    if (queue != nil && callbackBlock != nil)
    {
        [queue addOperationWithBlock: ^{
            callbackBlock (error);
        }];
    }
}



// ---------------------------------------------------------
#pragma mark - Wrapper around system date
// ---------------------------------------------------------

/**
 Internal method that returns the fakeSystemDate, if it's
 been set and if we're in debug mode, or the real system
 date otherwise.
 */
- (NSDate *) systemDate
{
    NSDate *date = nil;

    if ([APCUtilities isInDebuggingMode] && self.fakeSystemDate != nil)
    {
        date = self.fakeSystemDate;
    }
    else
    {
        date = [NSDate date];
    }

    return date;
}

- (void) clearFakeSystemDate
{
    /*
     queue this along with all other operations on our
     internal queue.
     */
    [self.queryQueue addOperationWithBlock:^{

        self.fakeSystemDate = nil;
        
    }];
}



// ---------------------------------------------------------
#pragma mark - Are we talkin' to the server?
// ---------------------------------------------------------

- (BOOL) isServerDisabled
{
    APCAppDelegate *app = [APCAppDelegate sharedAppDelegate];
    BOOL result = app.dataSubstrate.parameters.bypassServer;

#if DEVELOPMENT
    result = YES;
#endif

    return result;
}



// ---------------------------------------------------------
#pragma mark - The TaskGroup Cache
// ---------------------------------------------------------

/*
 The three methods in this section use the "@synchronized"
 keyword.  This means precisely the following:

 -  They read and change the same array.

 -  They are called by a couple of methods from at least
    2 threads, and are frequently called at the same time.
 
 -  Each change to that array takes several steps.
    Those steps have to happen together if we want the
    array and its contents to be make sense.
 */

- (NSArray *) cachedTaskGroupsForDayOfDate: (NSDate *) date
                    forTasksMatchingFilter: (NSPredicate *) taskFilter
{
    APCTaskGroupCacheEntry *foundCacheEntry = nil;

    @synchronized (self.taskGroupCacheMutex)
    {
        for (APCTaskGroupCacheEntry *cacheEntry in self.taskGroupCache)
        {
            BOOL bothTaskFiltersAreNil          = taskFilter == nil && cacheEntry.taskFilter == nil;
            BOOL taskFiltersHaveSameDescription = [taskFilter.description isEqualToString: cacheEntry.taskFilter.description];

            if ([date.startOfDay isEqualToDate: cacheEntry.date.startOfDay] &&
                (bothTaskFiltersAreNil || taskFiltersHaveSameDescription))
            {
                foundCacheEntry = cacheEntry;
                break;
            }
        }
    }

    return foundCacheEntry.taskGroups;
}

- (void) cacheTaskGroups: (NSArray *) taskGroups
                 forDate: (NSDate *) date
               andFilter: (NSPredicate *) taskFilter
{
    @synchronized (self.taskGroupCacheMutex)
    {
        NSArray *cachedTaskGroups = [self cachedTaskGroupsForDayOfDate: date
                                                forTasksMatchingFilter: taskFilter];

        if (cachedTaskGroups == nil)
        {
            APCTaskGroupCacheEntry *cacheEntry = [[APCTaskGroupCacheEntry alloc] initWithDate: date
                                                                                   taskFilter: taskFilter
                                                                                   taskGroups: taskGroups];

            APCLogDebug (@"Caching task groups: %@", cacheEntry);

            [self.taskGroupCache addObject: cacheEntry];
        }
    }
}

- (void) clearTaskGroupCache
{
    @synchronized (self.taskGroupCacheMutex)
    {
        APCLogDebug (@"Clearing the task-group cache.");

        self.taskGroupCache = [NSMutableArray new];
    }
}



// ---------------------------------------------------------
#pragma mark - Utility Methods
// ---------------------------------------------------------

- (APCAppDelegate *) appDelegate
{
    return [APCAppDelegate sharedAppDelegate];
}

- (NSManagedObjectContext *) managedObjectContext
{
    return self.scheduleMOC;
}

- (NSArray *) arrayByRemovingElementsInArray: (NSArray *) stuffToRemove
                                   fromArray: (NSArray *) stuffToKeep
                comparingObjectsUsingIsEqual: (BOOL) shouldCompareEqualityNotPointers
{
    NSMutableArray *result = [NSMutableArray new];

    for (NSObject *thingyToKeep in stuffToKeep)
    {
        BOOL found = NO;

        for (NSObject *thingyToRemove in stuffToRemove)
        {
            BOOL theyreTheSame = (shouldCompareEqualityNotPointers ?
                                  [thingyToKeep isEqual: thingyToRemove] :
                                  thingyToKeep == thingyToRemove);

            if (theyreTheSame)
            {
                found = YES;
                break;
            }
        }

        if (! found)
        {
            [result addObject: thingyToKeep];
        }
    }
    
    return result;
}

@end
