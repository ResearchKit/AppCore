//
//  APCScheduleImporter.m
//  APCAppCore
//
//  Copyright (c) 2015, Apple Inc. All rights reserved. 
//  
//  Redistribution and use in source and binary forms, with or without modification,
//  are permitted provided that the following conditions are met:
//  
//  1.  Redistributions of source code must retain the above copyright notice, this
//  list of conditions and the following disclaimer.
//  
//  2.  Redistributions in binary form must reproduce the above copyright notice, 
//  this list of conditions and the following disclaimer in the documentation and/or 
//  other materials provided with the distribution. 
//  
//  3.  Neither the name of the copyright holder(s) nor the names of any contributors 
//  may be used to endorse or promote products derived from this software without 
//  specific prior written permission. No license is granted to the trademarks of 
//  the copyright holders even if such marks are included in this software. 
//  
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
//  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
//  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE 
//  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
//  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
//  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
//  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
//  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
//

#import "APCScheduleImporter.h"
#import <CoreData/CoreData.h>
#import <ResearchKit/ResearchKit.h>
#import "APCCompletedOneTimeTaskFilter.h"
#import "APCMatchingScheduleFilter.h"
#import "APCUniqueTaskIdFilter.h"
#import "APCGenericSurveyTaskViewController.h"
#import "APCLog.h"
#import "APCSchedule+AddOn.h"
#import "APCScheduleDebugPrinter.h"
#import "APCScheduleStartDateFilter.h"
#import "APCScheduleFilter.h"
#import "APCExistingTaskFilter.h"
#import "APCMatchingSourceFilter.h"
#import "APCScheduleSourceFilter.h"
#import "APCScheduleTaskMap.h"
#import "APCScheduleTaskMapEntry.h"
#import "APCScheduleInMapFilter.h"
#import "APCTask+AddOn.h"
#import "APCTask+Bridge.h"
#import "NSDate+Helper.h"
#import "NSError+APCAdditions.h"
#import "NSManagedObject+APCHelper.h"
#import "SBBSchedule+APCHelper.h"



// ---------------------------------------------------------
#pragma mark - Constants
// ---------------------------------------------------------

/**
 Controls whether we compute and show (very) detailed debugging
 printouts.  This will always be NO in a release build.
 */
static BOOL const kAPCShowDebugPrintouts = NO;

/**
 Error codes and messages generated by this class.
 */
typedef enum : NSUInteger {
    APCErrorCouldntFindSurveyFileCode,
    APCErrorInboundListOfSchedulesAndTasksIssuesCode,
    APCErrorLoadingNativeBridgeSurveyObjectCode,
    APCErrorLoadingSurveyFileCode,
    APCErrorParsingSurveyContentCode,
    APCErrorSavingEverythingCode
}   APCError;

static NSString * const APCErrorDomain                                              = @"APCErrorDomainImportTasksAndSchedules";
static NSString * const APCErrorCouldntFindSurveyFileReason                         = @"Can't Find Survey File";
static NSString * const APCErrorCouldntFindSurveyFileSuggestion                     = @"We couldn't find the specified survey file on the phone.  Did you misspell the filename, perhaps?";
static NSString * const APCErrorInboundListOfSchedulesAndTasksIssuesReason          = @"Inbound list of schedules and task have issues";
static NSString * const APCErrorInboundListOfSchedulesAndTasksIssuesSuggestion      = @"Inbound list of schedules and task ID's or versions conflict.";
static NSString * const APCErrorLoadingNativeBridgeSurveyObjectReason               = @"Can't Find Survey File";
static NSString * const APCErrorLoadingNativeBridgeSurveyObjectSuggestion           = @"We couldn't find the specified survey file on the phone.  Did you misspell the filename, perhaps?";
static NSString * const APCErrorLoadingSurveyFileReason                             = @"There was an error serializing the contents of a survey file";
static NSString * const APCErrorLoadingSurveyFileSuggestion                         = @"There was an error serializing the contents of a survey file. ";
static NSString * const APCErrorParsingSurveyContentReason                          = @"There was an error parsing the contents of a survey file";
static NSString * const APCErrorParsingSurveyContentSuggestion                      = @"There was an error parsing the contents of a survey file.";
static NSString * const APCErrorSavingEverythingReason                              = @"Error Saving New Schedules";
static NSString * const APCErrorSavingEverythingSuggestion                          = @"There was an error attempting to save the new schedules.";

/**
 JSON Mapping files
 */
static NSString * const kTaskIdToViewControllerMappingJSON                      = @"APHTaskIdToViewControllerMapping";

/**
 Keys and special values in the JSON dictionaries representing
 tasks and schedules.
 */
static NSString * const kScheduleDelayKey                      = @"delay";
static NSString * const kScheduleEndDateKey                    = @"endOn";
static NSString * const kScheduleExpiresKey                    = @"expires";
static NSString * const kScheduleIDValueLocallyGeneratedPrefix = @"autogenerated";
static NSString * const kScheduleIntervalKey                   = @"interval";
static NSString * const kScheduleListOfTasksKey                = @"tasks";
static NSString * const kScheduleMaxCountKey                   = @"maxCount";
static NSString * const kScheduleNotesKey                      = @"notes";
static NSString * const kScheduleReminderMessageKey            = @"reminderMessage";
static NSString * const kScheduleReminderOffsetKey             = @"reminderOffset";
static NSString * const kScheduleShouldRemindKey               = @"shouldRemind";
static NSString * const kScheduleStartDateKey                  = @"startOn";
static NSString * const kScheduleStringKey                     = @"scheduleString";
static NSString * const kScheduleTimesOfDayKey                 = @"times";
static NSString * const kScheduleTypeKey                       = @"scheduleType";
static NSString * const kScheduleTypeValueOnce                 = @"once";
static NSString * const kTaskClassNameKey                      = @"taskClassName";
static NSString * const kTaskCompletionTimeStringKey           = @"taskCompletionTimeString";
static NSString * const kTaskFileNameKey                       = @"taskFileName";
static NSString * const kTaskIDKey                             = @"taskID";
static NSString * const kTaskIsOptionalKey                     = @"optional";
static NSString * const kTaskSortStringKey                     = @"sortString";
static NSString * const kTaskTitleKey                          = @"taskTitle";
static NSString * const kTaskTypeKey                           = @"taskType";
static NSString * const kTaskTypeValueSurvey                   = @"survey";
static NSString * const kTaskUrlKey                            = @"taskUrl";
static NSString * const kTaskVersionNumberKey                  = @"version";


/**
 Formats for interpreting a JSON list of time values.
 Filled in during +load.
 */
static NSArray *legalTimeSpecifierFormats = nil;



// ---------------------------------------------------------
#pragma mark - The Class Body
// ---------------------------------------------------------


@implementation APCScheduleImporter

/**
 Sets global, static values the first time anyone calls this category.

 By definition, this method is called once per category, in a thread-safe
 way, the first time the category is sent a message -- basically, the first
 time we refer to any method declared in that category.

 Documentation:  the key sentence is actually in the documentation for
 +initialize:  "initialize is invoked only once per class. If you want
 to perform independent initialization for the class and for categories
 of the class, you should implement +load methods."

 Useful resources:
 -  http://stackoverflow.com/q/13326435
 -  https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/index.html#//apple_ref/occ/clm/NSObject/load
 -  https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/index.html#//apple_ref/occ/clm/NSObject/initialize
 */
+ (void) load
{
    legalTimeSpecifierFormats = @[@"H",
                                  @"HH",
                                  @"HH:mm",
                                  @"HH:mm:SS",
                                  @"HH:mm:SS.sss"
                                  ];
}


// ---------------------------------------------------------
#pragma mark - The Main Import Method
// ---------------------------------------------------------

/**
 Method:  -processSchedulesAndTasks

 Analyzes the specified JSON data for schedules and tasks, compares them
 with the existing and running schedules and tasks, and figures out which
 to import, update, terminate, or delete.
 
 This is the main "import" method -- the place where all tasks and schedules

 get into the app.

 @details
 See the attached PDF, ScheduleImportProcess.pdf, for a flow chart showing
 the business logic in this method.  Here's how it *works*.

 This method runs all imported and currently-running schedules through a set of
 "filters."  We dump the outputs from each filter into other filters, repeating
 this process until we've sorted the schedules into stuff we know how to act on.
 Thus, the sequence of filters embodies our business rules.

 As of this writing (July, 2015):  for an incoming set of schedules, we need to
 understand things like:
 
 1.  which of these schedules, if any, come from the server?
 2.  which of these schedules, if any, refer to completed, one-time tasks?
 3.  are any of these schedules identical to the currently-running schedule they're replacing?
 
 ...and 12 other such questions, each matching a filter icon in the flowchart.
 For each such question, we create a "filter":  a subclass of APCScheduleFilter.
 Each filter divides a set of schedules into two subsets:  those which "pass through"
 the filter, and those which don't.  I.e., the schedules where the answer to
 the filter's question is "yes," and those for which the answer is "no."

 To handle question 1 above, we wrote a "schedule source filter." That filter
 has a simple method that walks through a set of schedules, looks at each
 schedule's "scheduleSource" property, and comes up with two subsets: those
 with a scheduleSource of "server" (APCScheduleSourceServer), and those which
 don't have that source.  The schedules from the server will appear in the
 filter's -passed property, and schedules NOT from the server will appear in
 -failed.  At that point, we can make further decisions about those schedules
 based on whether or not they came from the server.

 From point of view of this method, outside the filter class, we can do that
 with very little code.  To create the sourceFilter:

 @code
 APCScheduleSourceFilter *sourceFilter = [APCScheduleSourceFilter new];
 @endcode
 
 To use the sourceFilter, we feed it a set of schedules and tell it which
 schedule source to think about:
 
 @code
 [sourceFilter split: someSetOfSchedules
          withSource: APCScheduleSourceServer];
 @endcode
 
 This gives us two more sets of schedules:  those from the server, and those
 from someplace other than the server.  We can now pass those subsets to other
 filters.  ...or use them however we like; they're just NSSets of Schedule
 objects, and use them however we need.  To use them in another filter, we
 might do:

 @code
 [someOtherFilter split: sourceFilter.passed
               withData: someOtherPieceOfData];
 @endcode
 
 Some filters have output properties other than -passed and -failed.  For
 example, the startDateFilter takes a date, and splits the schedules into
 3 subsets:  those whose startDate is before the date, those which start
 on that date, and those which start after that date.
 
 Please see APCScheduleFilter, and each Filter subclass, for more information
 about how the filters work.
 */
- (void) processSchedulesAndTasks: (NSArray *) arrayOfSchedulesAndTasks
                       fromSource: (APCScheduleSource) scheduleSource
                     usingContext: (NSManagedObjectContext *) context
              scheduleQueryEngine: (id <APCScheduleQueryEngine>) queryEngine
                       importDate: (NSDate *) importDate
                   returningError: (NSError * __autoreleasing *) errorToReturn
{
    // -----------------------------------------------------
    // Setup
    // -----------------------------------------------------

    NSDate *today = importDate;
    NSDate *relativeTimeBeforeStarting = [NSDate date];
    NSMutableString *printout = nil;
    NSError *finalErrorFromThisMethod = nil;
    NSError *errorFetchingCurrentSchedules = nil;
    APCScheduleDebugPrinter *printer = nil;
    NSString *sourceName = NSStringFromAPCScheduleSource (scheduleSource);

#if DEBUG
    if (kAPCShowDebugPrintouts)
    {
        printout = [NSMutableString new];
        printer = [APCScheduleDebugPrinter new];
    }
#endif


    // -----------------------------------------------------
    // Query and Import
    // -----------------------------------------------------

    NSArray *activeScheduleArray = [queryEngine querySchedulesActiveOnDayOfDate: today
                                                                     fromSource: APCScheduleSourceAll
                                                                      inContext: context
                                                                 returningError: & errorFetchingCurrentSchedules];

    NSArray *incomingScheduleArray = [self createSchedulesAndUpdateTasksFromIncomingData: arrayOfSchedulesAndTasks
                                                                               forSource: scheduleSource
                                                                               inContext: context
                                                                         usingImportDate: importDate];

    NSMutableSet *activeSchedules   = [NSMutableSet setWithArray: activeScheduleArray];
    NSMutableSet *incomingSchedules = [NSMutableSet setWithArray: incomingScheduleArray];

    if (activeScheduleArray == nil)
    {
        finalErrorFromThisMethod = errorFetchingCurrentSchedules;
    }


    // -----------------------------------------------------
    // Filters and metadata
    // -----------------------------------------------------

    NSSet *incomingTaskIds = [APCSchedule extractTaskIdsFromSchedules: incomingSchedules];

    APCScheduleTaskMap *activeScheduleMap    = [[APCScheduleTaskMap alloc] initWithSetOfSchedules: activeSchedules];
    APCScheduleTaskMap *incomingScheduleMap  = [[APCScheduleTaskMap alloc] initWithSetOfSchedules: incomingSchedules];
    APCScheduleTaskMap *recentScheduleMap    = [self queryMostRecentOwnersForTaskIds: incomingTaskIds usingContext: context];

    APCUniqueTaskIdFilter         *incomingSchedUniqueTaskFilter            = [APCUniqueTaskIdFilter new];
    APCExistingTaskFilter         *incomingSchedExistingTaskFilter          = [APCExistingTaskFilter new];
    APCCompletedOneTimeTaskFilter *incomingSchedCompletedOneTimeTaskFilter  = [APCCompletedOneTimeTaskFilter new];
    APCMatchingSourceFilter       *incomingSchedSameSourceFilter            = [APCMatchingSourceFilter new];
    APCScheduleInMapFilter        *incomingSchedTasksAreActiveFilter        = [APCScheduleInMapFilter new];
    APCMatchingScheduleFilter     *incomingSchedIsIdenticalFilter           = [APCMatchingScheduleFilter new];
    APCScheduleSourceFilter       *incomingSchedFromServerFilter            = [APCScheduleSourceFilter new];
    APCScheduleInMapFilter        *incomingSchedServerActiveFilter          = [APCScheduleInMapFilter new];

    APCScheduleSourceFilter       *activeSchedFromThisSourceFilter          = [APCScheduleSourceFilter new];
    APCMatchingScheduleFilter     *activeSchedIdenticalToIncomingFilter     = [APCMatchingScheduleFilter new];
    APCScheduleInMapFilter        *activeSchedWithRefreshedTasksFilter      = [APCScheduleInMapFilter new];
    APCScheduleStartDateFilter    *activeSchedButSupersededDateFilter       = [APCScheduleStartDateFilter new];
    APCScheduleStartDateFilter    *activeSchedTaskNotRefreshedDateFilter    = [APCScheduleStartDateFilter new];
    APCScheduleInMapFilter        *activeSchedOvertakenByIncomingFilter     = [APCScheduleInMapFilter new];
    APCScheduleStartDateFilter    *activeSchedOvertakenDateFilter           = [APCScheduleStartDateFilter new];



    // -----------------------------------------------------
    // Analyze
    // -----------------------------------------------------

    /*
     This section implements the decision tree shown in the attached PDF file,
     ScheduleImportProcess.pdf, as described in the method header.  When you
     read this, it might help to split the screen, with the flow chart on one
     side and this code on the other, so you can see how each filter call maps
     to a decision in the tree.

     The basic plan:  for any given input someData,
     
     -  use filter A to split someData using <helper>     <-- input to filter A
     -  use filter B to split [A passed] using <helper>   <-- SOME of the output from A:  stuff that passed the A filter
     -  use filter C to split [B passed] using <helper>
     -  use filter D to split [A failed] using <helper>   <-- the REST of the output from A:  stuff that did NOT pass the A filter
     -  use filter E to split [D passed] using <helper>
     -  etc.
     
     Thus the outputs from every filter become the inputs for other filters,
     until we decide whether to keep, delete, or modify the output from a
     filter.  The next section shows those final actions.
     */

    //
    // Decide what to do with incoming schedules.
    //

    [incomingSchedUniqueTaskFilter            split: incomingSchedules];
    [incomingSchedExistingTaskFilter          split: incomingSchedUniqueTaskFilter.passed            withMap:    recentScheduleMap];
    [incomingSchedCompletedOneTimeTaskFilter  split: incomingSchedExistingTaskFilter.passed          withMap:    recentScheduleMap];
    [incomingSchedSameSourceFilter            split: incomingSchedCompletedOneTimeTaskFilter.failed  withMap:    recentScheduleMap];
    [incomingSchedTasksAreActiveFilter        split: incomingSchedSameSourceFilter.passed            withMap:    activeScheduleMap];
    [incomingSchedIsIdenticalFilter           split: incomingSchedTasksAreActiveFilter.passed        withMap:    activeScheduleMap];
    [incomingSchedFromServerFilter            split: incomingSchedSameSourceFilter.failed            withSource: APCScheduleSourceServer];
    [incomingSchedServerActiveFilter          split: incomingSchedFromServerFilter.passed            withMap:    activeScheduleMap];


    //
    // Decide what to do with active schedules.
    //

    APCScheduleTaskMap *incomingOverridingActiveMap = [[APCScheduleTaskMap alloc] initWithSetOfSchedules: incomingSchedServerActiveFilter.passed];

    [activeSchedFromThisSourceFilter        split: activeSchedules                              withSource: scheduleSource];
    [activeSchedWithRefreshedTasksFilter    split: activeSchedFromThisSourceFilter.passed       withMap:    incomingScheduleMap];
    [activeSchedIdenticalToIncomingFilter   split: activeSchedWithRefreshedTasksFilter.passed   withMap:    incomingScheduleMap];
    [activeSchedButSupersededDateFilter     split: activeSchedIdenticalToIncomingFilter.failed  withDate:   today];
    [activeSchedTaskNotRefreshedDateFilter  split: activeSchedWithRefreshedTasksFilter.failed   withDate:   today];
    [activeSchedOvertakenByIncomingFilter   split: activeSchedFromThisSourceFilter.failed       withMap:    incomingOverridingActiveMap];
    [activeSchedOvertakenDateFilter         split: activeSchedOvertakenByIncomingFilter.passed  withDate:   today];



    // -----------------------------------------------------
    // Print the analysis so far, before we change some of those objects
    // -----------------------------------------------------
    {
        /*
         The above curly brace is just so I can collapse this section in Xcode.
         */

        [printout appendFormat:
         @"\n\n======================= Importing new batch of schedules from [%@] starting at [%@] =======================\n\n",
         sourceName,
         [printer.class stringWithMillisecondsFromDate: relativeTimeBeforeStarting]];


        [printout appendString: @"--------\nAnalyzing incoming schedules\n--------\n"];

        [printer printSetOfSchedules: incomingSchedules                               intoMutableString: printout  withLabel: @"Incoming schedules"];
        [printer printSetOfSchedules: incomingSchedUniqueTaskFilter.passed            intoMutableString: printout  withLabel: @"...without duplicate task IDs (we'll keep processing these)"];
        [printer printSetOfSchedules: incomingSchedUniqueTaskFilter.failed            intoMutableString: printout  withLabel: @"...with duplicate task IDs (we'll delete these)"];
        [printer printSetOfSchedules: incomingSchedExistingTaskFilter.failed          intoMutableString: printout  withLabel: @"...with brand-new tasks"];
        [printer printSetOfSchedules: incomingSchedExistingTaskFilter.passed          intoMutableString: printout  withLabel: @"...with existing tasks"];
        [printer printSetOfSchedules: incomingSchedCompletedOneTimeTaskFilter.passed  intoMutableString: printout  withLabel: @"...for existing, completed, one-time tasks (we'll delete these)"];
        [printer printSetOfSchedules: incomingSchedCompletedOneTimeTaskFilter.failed  intoMutableString: printout  withLabel: @"...for not-yet-completed tasks (we'll keep processing these)"];
        [printer printSetOfSchedules: incomingSchedSameSourceFilter.passed            intoMutableString: printout  withLabel: @"...matching existing sources for not-yet-completed tasks"];
        [printer printSetOfSchedules: incomingSchedSameSourceFilter.failed            intoMutableString: printout  withLabel: @"...NOT matching existing sources for not-yet-completed tasks"];
        [printer printSetOfSchedules: incomingSchedTasksAreActiveFilter.passed        intoMutableString: printout  withLabel: @"...(matching existing sources, not yet completed) for active tasks"];
        [printer printSetOfSchedules: incomingSchedTasksAreActiveFilter.failed        intoMutableString: printout  withLabel: @"...(matching existing sources, not yet completed) for inactive tasks"];
        [printer printSetOfSchedules: incomingSchedIsIdenticalFilter.passed           intoMutableString: printout  withLabel: @"...which duplicate active schedules (we'll delete these)"];
        [printer printSetOfSchedules: incomingSchedIsIdenticalFilter.failed           intoMutableString: printout  withLabel: @"...which don't duplicate active schedules (we'll keep these)"];
        [printer printSetOfSchedules: incomingSchedFromServerFilter.passed            intoMutableString: printout  withLabel: @"...with new source for old task, from server"];
        [printer printSetOfSchedules: incomingSchedFromServerFilter.failed            intoMutableString: printout  withLabel: @"...with new source for old task, not from server (we'll delete these)"];
        [printer printSetOfSchedules: incomingSchedServerActiveFilter.passed          intoMutableString: printout  withLabel: @"...trying to control active tasks"];
        [printer printSetOfSchedules: incomingSchedServerActiveFilter.failed          intoMutableString: printout  withLabel: @"...NOT trying to control active tasks"];


        [printout appendString: @"--------\nAnalyzing active schedules\n--------\n"];

        [printer printSetOfSchedules: activeSchedules                                   intoMutableString: printout  withLabel: @"Active schedules"];
        [printer printSetOfSchedules: activeSchedFromThisSourceFilter.passed            intoMutableString: printout  withLabel: [NSString stringWithFormat: @"...from this source, %@", sourceName]];
        [printer printSetOfSchedules: activeSchedFromThisSourceFilter.failed            intoMutableString: printout  withLabel: @"...from other sources"];
        [printer printSetOfSchedules: activeSchedWithRefreshedTasksFilter.passed        intoMutableString: printout  withLabel: @"...from this source with new schedules"];
        [printer printSetOfSchedules: activeSchedWithRefreshedTasksFilter.failed        intoMutableString: printout  withLabel: @"...from this source without new schedules"];
        [printer printSetOfSchedules: activeSchedIdenticalToIncomingFilter.passed       intoMutableString: printout  withLabel: @"...identical to new schedules"];
        [printer printSetOfSchedules: activeSchedIdenticalToIncomingFilter.failed       intoMutableString: printout  withLabel: @"...different from new schedules"];
        [printer printSetOfSchedules: activeSchedButSupersededDateFilter.before         intoMutableString: printout  withLabel: @"...superseded, downloaded in the past"];
        [printer printSetOfSchedules: activeSchedButSupersededDateFilter.during         intoMutableString: printout  withLabel: @"...superseded, downloaded sometime today (we'll delete these)"];
        [printer printSetOfSchedules: activeSchedButSupersededDateFilter.after          intoMutableString: printout  withLabel: @"...superseded, downloaded in the future"];
        [printer printSetOfSchedules: activeSchedTaskNotRefreshedDateFilter.before      intoMutableString: printout  withLabel: @"...not refreshed, downloaded in the past"];
        [printer printSetOfSchedules: activeSchedTaskNotRefreshedDateFilter.during      intoMutableString: printout  withLabel: @"...not refreshed, downloaded sometime today (we'll delete these)"];
        [printer printSetOfSchedules: activeSchedTaskNotRefreshedDateFilter.after       intoMutableString: printout  withLabel: @"...not refreshed, downloaded in the future"];
        [printer printSetOfSchedules: activeSchedOvertakenByIncomingFilter.passed       intoMutableString: printout  withLabel: @"...from other sources that ARE being overtaken by incoming"];
        [printer printSetOfSchedules: activeSchedOvertakenByIncomingFilter.failed       intoMutableString: printout  withLabel: @"...from other sources NOT being overtaken by incoming"];
        [printer printSetOfSchedules: activeSchedOvertakenDateFilter.before             intoMutableString: printout  withLabel: @"...being overtaken, downloaded in the past (we'll terminate these)"];
        [printer printSetOfSchedules: activeSchedOvertakenDateFilter.during             intoMutableString: printout  withLabel: @"...being overtaken, downloaded sometime today (we'll delete these)"];
        [printer printSetOfSchedules: activeSchedOvertakenDateFilter.after              intoMutableString: printout  withLabel: @"...being overtaken, downloaded in the future (we'll delete these)"];
    }


    // -----------------------------------------------------
    // Do it
    // -----------------------------------------------------

    /*
     By the time we get here, we should have:
     - stuff to leave as-is:  currently running and OK that way, or newly imported and accepted
     - stuff to delete:       imported earlier today; or illegal incoming stuff
     - stuff to terminate:    previous schedules for the same tasks
     */

    [self terminateSchedules: activeSchedButSupersededDateFilter.before                 asOfDate: today.dayBefore];
    [self terminateSchedules: activeSchedTaskNotRefreshedDateFilter.before              asOfDate: today.dayBefore];
    [self terminateSchedules: activeSchedOvertakenDateFilter.before                     asOfDate: today.dayBefore];

    [self deleteSchedulesButNotTasks: incomingSchedUniqueTaskFilter.failed              inContext: context];
    [self deleteSchedulesButNotTasks: incomingSchedCompletedOneTimeTaskFilter.passed    inContext: context];
    [self deleteSchedulesButNotTasks: incomingSchedIsIdenticalFilter.passed             inContext: context];
    [self deleteSchedulesButNotTasks: incomingSchedFromServerFilter.failed              inContext: context];

    [self deleteSchedulesButNotTasks: activeSchedButSupersededDateFilter.during         inContext: context];
    [self deleteSchedulesButNotTasks: activeSchedButSupersededDateFilter.after          inContext: context];
    [self deleteSchedulesButNotTasks: activeSchedTaskNotRefreshedDateFilter.during      inContext: context];
    [self deleteSchedulesButNotTasks: activeSchedTaskNotRefreshedDateFilter.after       inContext: context];
    [self deleteSchedulesButNotTasks: activeSchedOvertakenDateFilter.during             inContext: context];
    [self deleteSchedulesButNotTasks: activeSchedOvertakenDateFilter.after              inContext: context];

    /*
     These arrays contain the sets of schedules we choose not to touch:  stuff
     we want to keep running, and/or start running for the first time.  Putting
     them in arrays is just a debugging technique:  we can click the filter
     name in Xcode, and let Xcode's highlighting help us make sure we're
     handling every output from every filter.
     */
    NSArray * __unused incomingSchedulesToKeep = @[
                                                   incomingSchedExistingTaskFilter.failed,
                                                   incomingSchedTasksAreActiveFilter.failed,
                                                   incomingSchedIsIdenticalFilter.failed,
                                                   incomingSchedServerActiveFilter.passed,
                                                   incomingSchedServerActiveFilter.failed,
                                                   ];

    NSArray * __unused activeSchedulesToLeaveRunning = @[
                                                         activeSchedIdenticalToIncomingFilter.passed,
                                                         activeSchedOvertakenByIncomingFilter.failed,
                                                         ];



    // -----------------------------------------------------
    // Save
    // -----------------------------------------------------

    if (! context.hasChanges)
    {
        [printout appendString: @"\n...which means, all told, there's nothing to save.  We're done.\n\n"];
    }
    else
    {
        NSManagedObject *anySaveableObject = incomingSchedules.anyObject;
        NSError *errorSavingEverything = nil;
        BOOL saved = [anySaveableObject saveToPersistentStore: & errorSavingEverything];

        if (! saved)
        {
            finalErrorFromThisMethod = [NSError errorWithCode: APCErrorSavingEverythingCode
                                                       domain: APCErrorDomain
                                                failureReason: APCErrorSavingEverythingReason
                                           recoverySuggestion: APCErrorSavingEverythingSuggestion
                                                  nestedError: errorSavingEverything];
        }
    }



    // -----------------------------------------------------
    // Summarize and print
    // -----------------------------------------------------

    // Summarize
    {
        NSArray *currentSchedulesAfterImport = [queryEngine querySchedulesActiveOnDayOfDate: today
                                                                                 fromSource: APCScheduleSourceAll
                                                                                  inContext: context
                                                                             returningError: & errorFetchingCurrentSchedules];

        NSArray *allSchedulesInTheSystem = [context executeFetchRequest: [APCSchedule request] error: nil];

        [printout appendString: @"--------\nResults\n--------\n"];

        [printer printArrayOfSchedules: currentSchedulesAfterImport                     intoMutableString: printout  withLabel: @"Current schedules after import"];
        [printer printArrayOfSchedules: allSchedulesInTheSystem                         intoMutableString: printout  withLabel: @"All schedules in the system"];
        [printer printSetOfSchedules:   activeSchedButSupersededDateFilter.before       intoMutableString: printout  withLabel: @"Terminated schedules"];
        [printer printSetOfSchedules:   activeSchedButSupersededDateFilter.before       intoMutableString: printout  withLabel: @"active schedules:  superseded"];
        [printer printSetOfSchedules:   activeSchedTaskNotRefreshedDateFilter.before    intoMutableString: printout  withLabel: @"active schedules:  not refreshed by this import"];
        [printer printSetOfSchedules:   activeSchedOvertakenDateFilter.before           intoMutableString: printout  withLabel: @"active schedules:  taken over by server"];



        // Print
        NSDate *relativeTimeAtEnd = [NSDate date];
        NSTimeInterval totalTime = [relativeTimeAtEnd timeIntervalSinceDate: relativeTimeBeforeStarting];
        [printout appendFormat: @"\nTotal time: %f seconds\n", totalTime];

        [printout appendFormat:
         @"======================= end batch of schedules from [%@] at [%@] =======================\n\n",
         sourceName,
         [printer.class stringWithMillisecondsFromDate: relativeTimeBeforeStarting]];
        
        NSLog (@"%@", printout);
    }



    // -----------------------------------------------------
    // Done!
    // -----------------------------------------------------

    if (errorToReturn != nil)
    {
        * errorToReturn = finalErrorFromThisMethod;
    }
}



// ---------------------------------------------------------
#pragma mark - Delete and Disable
// ---------------------------------------------------------

- (void) terminateSchedules: (NSSet *) schedulesToTerminate
                   asOfDate: (NSDate *) terminationDate
{
    NSDate *endOfDay = terminationDate.endOfDay;   // 23:59:59

    for (APCSchedule *schedule in schedulesToTerminate)
    {
        schedule.effectiveEndDate = endOfDay;
    }
}

- (void) deleteSchedulesButNotTasks: (NSSet *) schedulesToDelete
                          inContext: (NSManagedObjectContext *) context
{
    for (APCSchedule *schedule in schedulesToDelete)
    {
        [context deleteObject: schedule];
    }
}



// ---------------------------------------------------------
#pragma mark - Create
// ---------------------------------------------------------

- (NSArray *) createSchedulesAndUpdateTasksFromIncomingData: (NSArray *) incomingSchedulesAndTasks
                                                  forSource: (APCScheduleSource) scheduleSource
                                                  inContext: (NSManagedObjectContext *) context
                                            usingImportDate: (NSDate *) importDate
{
    NSMutableArray *schedules = [NSMutableArray new];

    for (NSDictionary *scheduleData in incomingSchedulesAndTasks)
    {
        APCSchedule *schedule = [self createOneScheduleAndItsTasksFromJsonData: scheduleData
                                                                    fromSource: scheduleSource
                                                                  usingContext: context
                                                                 andImportDate: importDate];

        [schedules addObject: schedule];
    }

    return schedules;
}

- (APCSchedule *) createOneScheduleAndItsTasksFromJsonData: (NSDictionary *) inboundScheduleData
                                                fromSource: (APCScheduleSource) scheduleSource
                                              usingContext: (NSManagedObjectContext *) context
                                             andImportDate: (NSDate *) importDate
{
    APCSchedule *schedule   = [APCSchedule newObjectForContext: context];
    schedule.scheduleSource = @(scheduleSource);

    NSMutableDictionary *scheduleData = inboundScheduleData.mutableCopy;


    //
    // Pre-import data validation.
    //

    id requestedStartDate = [self nilIfNull: scheduleData [kScheduleStartDateKey]];
    id requestedEndDate   = [self nilIfNull: scheduleData [kScheduleEndDateKey]];
    id timesOfDay         = [self nilIfNull: scheduleData [kScheduleTimesOfDayKey] ];

    if ([requestedStartDate isKindOfClass: [NSString class]])
    {
        requestedStartDate = [NSDate dateWithISO8601String: requestedStartDate];
    }

    if ([requestedEndDate isKindOfClass: [NSString class]])
    {
        requestedEndDate = [NSDate dateWithISO8601String: requestedEndDate];
    }

    if ([timesOfDay isKindOfClass: [NSArray class]])
    {
        timesOfDay = [self serializedTimesOfDayStringFromISO8601TimesOfDayInArray: timesOfDay];
    }

    scheduleData [kScheduleStartDateKey]  = [self nullIfNil: requestedStartDate];
    scheduleData [kScheduleEndDateKey]    = [self nullIfNil: requestedEndDate];
    scheduleData [kScheduleTimesOfDayKey] = [self nullIfNil: timesOfDay];



    //
    // Copy the data into our local object.
    //

    schedule.delay                  = [self nilIfNull: scheduleData [kScheduleDelayKey]];
    schedule.endsOn                 = [self nilIfNull: scheduleData [kScheduleEndDateKey]];
    schedule.expires                = [self nilIfNull: scheduleData [kScheduleExpiresKey]];
    schedule.interval               = [self nilIfNull: scheduleData [kScheduleIntervalKey]];
    schedule.maxCount               = [self nilIfNull: scheduleData [kScheduleMaxCountKey]];
    schedule.notes                  = [self nilIfNull: scheduleData [kScheduleNotesKey]];
    schedule.reminderMessage        = [self nilIfNull: scheduleData [kScheduleReminderMessageKey]];         // if from Sage:  "label"
    schedule.reminderOffset         = [self nilIfNull: scheduleData [kScheduleReminderOffsetKey]];
    schedule.scheduleString         = [self nilIfNull: scheduleData [kScheduleStringKey]];
    schedule.scheduleType           = [self nilIfNull: scheduleData [kScheduleTypeKey]];
    schedule.shouldRemind           = [self nilIfNull: scheduleData [kScheduleShouldRemindKey]];
    schedule.startsOn               = [self nilIfNull: scheduleData [kScheduleStartDateKey]];
    schedule.timesOfDay             = [self nilIfNull: scheduleData [kScheduleTimesOfDayKey]];


    //
    // Add data validation, defaults, and calculations.
    //

    /*
     Start date:  this morning, at midnight, whenever "this
     morning" is.  NOT the app-installation time; that might
     be months ago, which would not reflect the user's
     experience of this schedule -- it didn't exist back
     then.
     */
    NSDate *beginningOfTime = importDate.startOfDay;

    if (schedule.startsOn == nil)
    {
        schedule.startsOn = beginningOfTime;
    }


    /*
     Effective start date = start date + delay.  Then round to midnight that
     morning.  See this -compute method for details.
     */
    schedule.effectiveStartDate = [schedule computeDelayedStartDateFromDate: schedule.startsOn];


    /*
     Effective end date:  the end date + the expiration period, then round to
     the end of that day.  See this -compute method for details.
     */
    schedule.effectiveEndDate = [schedule computeExpirationDateForScheduledDate: schedule.endsOn];


    //
    // Creating Tasks
    //
    NSArray *tasks = scheduleData [kScheduleListOfTasksKey];

    for (NSDictionary *taskData in tasks)
    {
        APCTask *task = [self createOrUpdateTaskFromJsonData: taskData
                                                   inContext: context];
        if (task)
        {
            [schedule addTasksObject: task];
        }
    }


    //
    // Done!
    //
    return schedule;
}

/**
 When we get data from a file or from the server, we first convert it to a set
 of dictionaries.  Each dictionary contains one Schedule.  That Schedule
 contains a list of the Tasks the schedule should manage.  Then we loop through
 those Schedules, creating each one.  Within that "create schedule" method, we
 then loop through all the Tasks it's supposed to manage, and create each of
 THOSE.  This method does that part: creates a single Task, when we're looping
 through the list of tasks attached to inbound schedule data.
 */
- (APCTask *) createOrUpdateTaskFromJsonData: (NSDictionary *) taskData
                                   inContext: (NSManagedObjectContext *) context
{
    APCTask  *task              = nil;
    NSString *taskId            = [self nilIfNull: taskData [kTaskIDKey]];
    NSNumber *taskVersionNumber = [self nilIfNull: taskData [kTaskVersionNumberKey]];

    NSSet *tasks = [APCTask querySavedTasksWithTaskIds: [NSSet setWithObject: taskId]
                                          usingContext: context];

    if (tasks)
    {
        task = tasks.anyObject;
    }

    if (task == nil)
    {
        task = [APCTask newObjectForContext: context];
        task.taskID = taskId;
        task.taskVersionNumber = taskVersionNumber;
    }

    [self updateTask: task
            withData: taskData];

    return task;
}

- (void) updateTask: (APCTask *) task
           withData: (NSDictionary *) taskData
{
    //
    // Update the task with potentially new data
    // (or add it for the first time, if we're creating a task).
    //
    task.taskHRef                   = [self nilIfNull: taskData [kTaskUrlKey]];                     // Sage-only?
    task.taskTitle                  = [self nilIfNull: taskData [kTaskTitleKey]];                   // sage and us
    task.sortString                 = [self nilIfNull: taskData [kTaskSortStringKey]];              // us-only, for now
    task.taskClassName              = [self nilIfNull: taskData [kTaskClassNameKey]];               // sage and us, because we add to sage
    task.taskCompletionTimeString   = [self nilIfNull: taskData [kTaskCompletionTimeStringKey]];    // us-only?
    task.taskContentFileName        = [self nilIfNull: taskData [kTaskFileNameKey]];                // us-only?
    task.taskIsOptional             = [self nilIfNull: taskData [kTaskIsOptionalKey]];              // us for now, Sage eventually?


    if ([task.taskTitle stringByTrimmingCharactersInSet: [NSCharacterSet whitespaceAndNewlineCharacterSet]].length == 0)
    {
        APCLogDebug (@"\n-------------\nWARNING!  About to create a Task with an empty title!  taskData and task are:  \n%@\n%@\n----------------", taskData, task);
    }

    if (task.taskContentFileName)
    {
        id <ORKTask> survey = [self surveyFromFileBaseName: task.taskContentFileName];
        
        if (survey)
        {
            task.rkTask = survey;
        }
    }
}

- (BOOL) updateTasksInSchedules: (NSArray *) schedulesThatAreAlreadyPerfect
               fromIncomingData: (NSArray *) incomingScheduleAndTaskData
{
    BOOL result = NO;

    for (APCSchedule *schedule in schedulesThatAreAlreadyPerfect)
    {
        for (APCTask *task in schedule.tasks)
        {
            NSString *taskId = task.taskID;
            NSNumber *taskVersion = task.taskVersionNumber;
            NSDictionary *taskData = [self extractTaskDataFromIncomingListOfSchedulesAndTasks: incomingScheduleAndTaskData
                                                                               withThisTaskId: taskId
                                                                               andThisVersion: taskVersion];
            [self updateTask: task
                    withData: taskData];
        }
    }

    return result;
}

- (id <ORKTask>) surveyFromFileBaseName: (NSString *) surveyContentFileBaseName
{
    id <ORKTask> rkSurvey = nil;

    NSString *surveyFilePath = [[NSBundle mainBundle] pathForResource: surveyContentFileBaseName
                                                               ofType: kAPCFileExtension_JSON];

    if (! surveyFilePath)
    {
        NSString *fullFileName = [NSString stringWithFormat: @"%@.%@", surveyContentFileBaseName, kAPCFileExtension_JSON];

        NSError *errorFindingSurveyFile = [NSError errorWithCode: APCErrorCouldntFindSurveyFileCode
                                                          domain: APCErrorDomain
                                                   failureReason: APCErrorCouldntFindSurveyFileReason
                                              recoverySuggestion: APCErrorCouldntFindSurveyFileSuggestion
                                                 relatedFilePath: fullFileName
                                                      relatedURL: nil
                                                     nestedError: nil];

        APCLogError2 (errorFindingSurveyFile);
    }

    else
    {
        NSError *errorLoadingSurveyFile = nil;
        NSData *jsonData = [NSData dataWithContentsOfFile: surveyFilePath
                                                  options: 0
                                                    error: & errorLoadingSurveyFile];

        if (! jsonData)
        {
            NSError *error = [NSError errorWithCode: APCErrorLoadingSurveyFileCode
                                             domain: APCErrorDomain
                                      failureReason: APCErrorLoadingSurveyFileReason
                                 recoverySuggestion: APCErrorLoadingSurveyFileSuggestion
                                        nestedError: errorLoadingSurveyFile];

            APCLogError2 (error);
        }

        else
        {
            NSError *errorParsingSurveyContent = nil;
            NSDictionary *surveyContent = [NSJSONSerialization JSONObjectWithData: jsonData
                                                                          options: 0
                                                                            error: & errorParsingSurveyContent];
            if (! surveyContent)
            {
                NSError *error = [NSError errorWithCode: APCErrorParsingSurveyContentCode
                                                 domain: APCErrorDomain
                                          failureReason: APCErrorParsingSurveyContentReason
                                     recoverySuggestion: APCErrorParsingSurveyContentSuggestion
                                            nestedError: errorParsingSurveyContent];

                APCLogError2 (error);
            }

            else
            {
                @try
                {
                    id manager = SBBComponent(SBBSurveyManager);
                    SBBSurvey *survey = [[manager objectManager] objectFromBridgeJSON: surveyContent];
                    rkSurvey = [APCTask rkTaskFromSBBSurvey: survey];
                }
                @catch (NSException *exception)
                {
                    NSError *error = [NSError errorWithCode: APCErrorLoadingNativeBridgeSurveyObjectCode
                                                     domain: APCErrorDomain
                                              failureReason: APCErrorLoadingNativeBridgeSurveyObjectReason
                                         recoverySuggestion: APCErrorLoadingNativeBridgeSurveyObjectSuggestion
                                            relatedFilePath: surveyFilePath
                                                 relatedURL: nil
                                                nestedError: nil
                                              otherUserInfo: @{ @"exception": exception,
                                                                @"stackTrace": exception.callStackSymbols }];

                    APCLogError2 (error);
                }
                @finally
                {

                }
            }
        }
    }
    
    return rkSurvey;
}



// ---------------------------------------------------------
#pragma mark - Queries
// ---------------------------------------------------------

- (APCScheduleTaskMap *) queryMostRecentOwnersForTaskIds: (NSSet *) taskIds
                                            usingContext: (NSManagedObjectContext *) context
{
    APCScheduleTaskMap *map = [APCScheduleTaskMap new];

    NSSet *tasks = [APCTask querySavedTasksWithTaskIds: taskIds usingContext: context];

    for (APCTask *task in tasks)
    {
        if (task.taskID.length)
        {
            APCSchedule *mostRecentSchedule = task.mostRecentSchedule;

            APCScheduleTaskMapEntry *entry = [[APCScheduleTaskMapEntry alloc] initWithTaskId: task.taskID
                                                                                        task: task
                                                                                    schedule: mostRecentSchedule];

            [map setEntry: entry forTaskId: task.taskID];
        }
    }
    
    return map;
}



// ---------------------------------------------------------
#pragma mark - JSON conversions
// ---------------------------------------------------------

/**
 Convert inbound Sage server data to an NSDictionary of keys we know how to
 look for.

 This lets us use the same method to process data downloaded from the server as
 we do data pulled from a local JSON file.
 */
- (NSDictionary *) extractJsonDataFromIncomingSageSchedule: (SBBSchedule *) sageSchedule
{
    NSNull *null                                    = [NSNull null];
    NSMutableDictionary *scheduleData               = [NSMutableDictionary new];
    NSMutableArray *activities                      = [NSMutableArray new];

    scheduleData [kScheduleReminderMessageKey]      = [self nullIfNil: sageSchedule.label];
    scheduleData [kScheduleTypeKey]                 = [self nullIfNil: sageSchedule.scheduleType];
    scheduleData [kScheduleStartDateKey]            = [self nullIfNil: sageSchedule.startsOn];
    scheduleData [kScheduleStringKey]               = [self nullIfNil: sageSchedule.cronTrigger];
    scheduleData [kScheduleExpiresKey]              = [self nullIfNil: sageSchedule.expires];
    scheduleData [kScheduleEndDateKey]              = [self nullIfNil: sageSchedule.endsOn];
    scheduleData [kScheduleListOfTasksKey]          = activities;

    // As a reminder to get these when Sage has a chance to add them.
    scheduleData [kScheduleIntervalKey]             = null; // [self nullIfNil: sageSchedule.interval];
    scheduleData [kScheduleTimesOfDayKey]           = null; // [self nullIfNil: sageSchedule.times];
    scheduleData [kScheduleMaxCountKey]             = null; // [self nullIfNil: sageSchedule.maxCount];
    
    // Set up TaskId->TaskViewController dictionary
    NSString *filePath = [[NSBundle mainBundle] pathForResource:kTaskIdToViewControllerMappingJSON ofType:@"json"];
    NSString *JSONString = [[NSString alloc] initWithContentsOfFile:filePath
                                                           encoding:NSUTF8StringEncoding
                                                              error:NULL];
    
    NSError *parseError;
    NSDictionary *mappingDictionary = [NSJSONSerialization JSONObjectWithData:[JSONString dataUsingEncoding:NSUTF8StringEncoding]
                                                                      options:NSJSONReadingMutableContainers
                                                                        error:&parseError];
    NSAssert(mappingDictionary != nil, @"ERROR trouble parsing taskId -> view controller mapping file", parseError);

    for (SBBActivity *activity in sageSchedule.activities)
    {
        if (activity.survey) {
            NSMutableDictionary *activityData = [NSMutableDictionary new];

            activityData [kTaskTitleKey]                = [self nullIfNil: activity.label];
            activityData [kTaskCompletionTimeStringKey] = [self nullIfNil: activity.labelDetail];
            activityData [kTaskTypeKey]                 = [self nullIfNil: activity.activityType];
            activityData [kTaskIDKey]                   = [self nullIfNil: activity.survey.identifier];
            activityData [kTaskVersionNumberKey]        = [self nullIfNil: activity.survey.createdOn.toStringInISO8601Format];
            activityData [kTaskUrlKey]                  = [self nullIfNil: activity.survey.href];
            activityData [kTaskClassNameKey]            = NSStringFromClass ([APCGenericSurveyTaskViewController class]);
            
            // When we start getting these from Sage, we'll use them.
            // In the mean time, noting them here, because we're using
            // them from our local disk files.
            
            activityData [kTaskFileNameKey]             = null;
            activityData [kTaskSortStringKey]           = null;

            [activities addObject: activityData];
        } else if (activity.task) {
            NSMutableDictionary *activityData = [NSMutableDictionary new];
            
            // ignore unrecognized tasks (probably added in a later app version)
            NSString *taskClassName = mappingDictionary[activity.task.identifier];
            if (taskClassName.length) {
                activityData [kTaskTitleKey]                = [self nullIfNil: activity.label];
                activityData [kTaskCompletionTimeStringKey] = [self nullIfNil: activity.labelDetail];
                activityData [kTaskTypeKey]                 = [self nullIfNil: activity.activityType];
                activityData [kTaskIDKey]                   = [self nullIfNil: activity.task.identifier];
                activityData [kTaskClassNameKey]            = taskClassName;
                
                // Not available for non survey tasks
                activityData [kTaskVersionNumberKey]    = null;
                activityData [kTaskUrlKey]              = null;
                
                // When we start getting these from Sage, we'll use them.
                // In the mean time, noting them here, because we're using
                // them from our local disk files.
                activityData [kTaskFileNameKey]             = null;
                activityData [kTaskSortStringKey]           = null;
                
                [activities addObject: activityData];
            }
        }
    }
    
    return scheduleData;
}

/**
 Crawls through the dictionaries and arrays in the incoming data until it finds
 a task dictionary containing the specified id and version.
 */
- (NSDictionary *) extractTaskDataFromIncomingListOfSchedulesAndTasks: (NSArray *) incomingScheduleAndTaskData
                                                       withThisTaskId: (NSString *) taskId
                                                       andThisVersion: (NSNumber *) taskVersion
{
    NSDictionary *foundTaskData = nil;
    NSMutableArray *taskDataWithSameIdAndVersion = [NSMutableArray new];

    for (NSDictionary *scheduleData in incomingScheduleAndTaskData)
    {
        NSArray *tasksForThisSchedule = scheduleData [kScheduleListOfTasksKey];

        for (NSDictionary *taskData in tasksForThisSchedule)
        {
            NSString *taskIdFromData      = [self nilIfNull: taskData [kTaskIDKey]];
            NSNumber *taskVersionFromData = [self nilIfNull: taskData [kTaskVersionNumberKey]];

            if ([self object1: taskId      equalsObject2: taskIdFromData]      &&
                [self object1: taskVersion equalsObject2: taskVersionFromData] )
            {
                [taskDataWithSameIdAndVersion addObject: taskData];
            }
        }
    }

    if (taskDataWithSameIdAndVersion.count == 0)
    {
        // Truly should never happen, since we got the taskID
        // and version from a previous pass through the data.
    }

    else if (taskDataWithSameIdAndVersion.count == 1)
    {
        // This is what we were expecting.
        foundTaskData = taskDataWithSameIdAndVersion.firstObject;
    }

    else    // .count > 1
    {
        NSError *tooManyTasksWithSameIdAndVersion = [NSError errorWithCode: APCErrorInboundListOfSchedulesAndTasksIssuesCode
                                                                    domain: APCErrorDomain
                                                             failureReason: APCErrorInboundListOfSchedulesAndTasksIssuesReason
                                                        recoverySuggestion: APCErrorInboundListOfSchedulesAndTasksIssuesSuggestion
                                                           relatedFilePath: nil
                                                                relatedURL: nil
                                                               nestedError: nil
                                                             otherUserInfo: @{ kTaskIDKey            : [self nullIfNil: taskId],
                                                                               kTaskVersionNumberKey : [self nullIfNil: taskVersion] }];
        APCLogError2 (tooManyTasksWithSameIdAndVersion);

        // Therefore, this is kinda undefined:
        foundTaskData = taskDataWithSameIdAndVersion.firstObject;
    }
    
    return foundTaskData;
}



// ---------------------------------------------------------
#pragma mark - Default Values
// ---------------------------------------------------------

- (NSDictionary *) defaultScheduleValues
{
    NSNull *null = [NSNull null];

    return @{
             kScheduleTypeKey               : kScheduleTypeValueOnce,
             kScheduleStringKey             : null,
             kTaskIDKey                     : null,
             kScheduleExpiresKey            : null,
             kScheduleDelayKey              : null,
             kScheduleStartDateKey          : null,
             kScheduleEndDateKey            : null,
             };
}

- (NSDictionary *) defaultTaskValues
{
    return @{};
}



// ---------------------------------------------------------
#pragma mark - Serializing times of day
// ---------------------------------------------------------

/*
 These two methods are very similar to a method in APCScheduleIntervalEnumerator.m.
 */

- (NSString *) serializedTimesOfDayStringFromISO8601TimesOfDayInArray: (NSArray *) timesOfDay
{
    NSDateFormatter *formatter = [NSDateFormatter new];
    formatter.locale = [NSLocale localeWithLocaleIdentifier: kAPCDateFormatLocaleEN_US_POSIX];

    NSString *result = nil;
    NSMutableArray *arrayOfValidStrings = [NSMutableArray new];

    if (timesOfDay != nil && [timesOfDay isKindOfClass: [NSArray class]])
    {
        for (id thingy in timesOfDay)
        {
            NSString *inboundTimeString = nil;

            /*
             Allow integers as times of day (3 = 3am, 14 =
             2pm, etc.) The spec only requests ISO 8601
             strings, but I think this will make life
             easier and equally practical, and it doesn't
             cost us much.
             */
            if ([thingy isKindOfClass: [NSNumber class]])
            {
                NSNumber *value = thingy;
                NSUInteger intValue = value.integerValue;
                float floatValue = value.floatValue;
                if (floatValue == (float) intValue &&
                    intValue >= kAPCTimeFirstLegalISO8601HourOfDay &&
                    intValue <= kAPCTimeLastLegalISO8601HourOfDay)
                {
                    inboundTimeString = value.stringValue;
                }
            }

            else if ([thingy isKindOfClass: [NSString class]])
            {
                inboundTimeString = thingy;
            }

            else
            {
                // Ignore all other data types.
            }

            if (inboundTimeString != nil)
            {
                NSDate *date = nil;

                for (NSString *format in legalTimeSpecifierFormats)
                {
                    formatter.dateFormat = format;
                    date = [formatter dateFromString: inboundTimeString];

                    if (date != nil)
                    {
                        break;
                    }
                }

                if (date != nil)
                {
                    [arrayOfValidStrings addObject: inboundTimeString];
                }
            }
        }
    }

    result = [arrayOfValidStrings componentsJoinedByString: @"|"];

    if (result.length == 0)
    {
        result = nil;
    }

    return result;
}

- (NSArray *) deserializedArrayOfDurationsSinceMidnightFromISO8601TimesOfDayString: (NSString *) serializedTimesOfDayString
{
    NSDateFormatter *formatter = [NSDateFormatter new];
    formatter.locale = [NSLocale localeWithLocaleIdentifier: kAPCDateFormatLocaleEN_US_POSIX];

    NSMutableArray *result = [NSMutableArray new];
    NSArray *iso8601TimeStrings = [serializedTimesOfDayString componentsSeparatedByString: @"|"];

    for (NSString *iso8601TimeString in iso8601TimeStrings)
    {
        NSDate *date = nil;

        for (NSString *format in legalTimeSpecifierFormats)
        {
            formatter.dateFormat = format;
            date = [formatter dateFromString: iso8601TimeString];

            if (date != nil)
            {
                break;
            }
        }

        if (date != nil)
        {
            NSDate *midnightOnThatDate = date.startOfDay;
            NSTimeInterval secondsSinceMidnight = [date timeIntervalSinceDate: midnightOnThatDate];
            [result addObject: @(secondsSinceMidnight)];
        }
    }
    
    if (result.count == 0)
    {
        result = nil;
    }
    
    return result;
}



// ---------------------------------------------------------
#pragma mark - Utilities
// ---------------------------------------------------------

/**
 Performs a "practical" version of "isEqual", returning YES if
 (a)  both objects are nil, or
 (b)  [object1 isEqual: object2]
 */
- (BOOL) object1: (id) object1
   equalsObject2: (id) object2
{
    return ((object1 == nil && object2 == nil) || [object1 isEqual: object2]);
}

/**
 Returns nil if the specified value is [NSNull null].  Otherwise, returns the
 value itself.

 Used to extract values from an NSDictionary and treat them as "nil" when that
 was the actual intent.
 */
- (id) nilIfNull: (id) someInputValue
{
    id outputValue = someInputValue;

    if (outputValue == [NSNull null])
    {
        outputValue = nil;
    }

    return outputValue;
}

/**
 Returns [NSNull null] if the specified value is [NSNull null], so that we can
 insert the specified item into a dictionary.  Otherwise, returns the value
 itself.
 */
- (id) nullIfNil: (id) someInputValue
{
    id outputValue = someInputValue;

    if (outputValue == nil)
    {
        outputValue = [NSNull null];
    }

    return outputValue;
}



@end
